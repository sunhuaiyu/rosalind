# rosalind_ba10i
# 
'''
Viterbi learning

Given: A sequence of emitted symbols x = x1 ... xn in an alphabet A, 
generated by a k-state HMM with unknown transition and emission probabilities, 
initial Transition and Emission matrices and a number of iterations i.

Return: A matrix of transition probabilities Transition and a matrix of 
emission probabilities Emission that maximizes Pr(x, π) over all possible 
transition and emission matrices and over all hidden paths π.
'''
import numpy as np
from numpy import log, argmax
import pandas as pd
from pandas import DataFrame
from io import StringIO


def Viterbi(X, states, hmm_T, hmm_E):
    '''Given a observation X and a HMM model, return the most likely hidden path.
    X and states are pre-encoded as integer arrays'''
    n = len(X)      # 
    init_states_p = 1.0 / len(states)  # assuming equal probabilities of all states
    
    # initialize Viterbi graph with each node contains [score, predecessor]
    V = {(i, j): [-np.inf, ''] for i in states for j in range(n)}

    # column zero
    for st in states:
        V[st, 0] = [ log(init_states_p) + log(hmm_E[st, X[0]]) , (None, -1) ]
    
    # forward
    for i in range(1, n):
        for current in states:
            in_edges = [V[prev, i-1][0] + log(hmm_T[prev, current]) for prev in states]            
            V[current, i] = [max(in_edges) + log(hmm_E[current, X[i]]), 
                            (states[argmax(in_edges)], i-1)]
                            
    # End node
    node = (states[argmax([V[s, n-1][0] for s in states])], n-1)

    # traceback and path reconstruction
    path = []
    while node[1] != -1:
        path.append(node[0])
        node = V[node][1]

    return path[::-1]


def hmm_params(X, path, alphabet, states):
    '''Given observation X and the hidden Markov chain path, 
    return HMM transition and emission matrices.
    Inputs are coded in integer arrays.'''
    
    transitions = np.zeros((len(states), len(states)), dtype=float) + 1e-10
    emissions   = np.zeros((len(states), len(alphabet)), dtype=float) + 1e-10
    
    for t in zip(path[:-1], path[1:]):
        transitions[t] += 1

    for a in zip(path, X):
        emissions[a] += 1

    transitions /=  transitions.sum(1, keepdims=True) 
    emissions /= emissions.sum(1, keepdims=True) 
    
    return transitions, emissions


f = open('rosalind_ba10i.txt').read().rstrip().split('\n--------\n')
n_iter = int(f[0])
alphabet = f[2].split()
alphabet_num = list(range(len(alphabet)))
alphabet_dict = dict(zip(alphabet, alphabet_num))
X = [alphabet_dict[i] for i in f[1]]   #observation sequence
states = f[3].split()
states_num = list(range(len(states)))

T = np.array([line.split()[1:] for line in f[4].split('\n')[1:]], dtype=float)
E = np.array([line.split()[1:] for line in f[5].split('\n')[1:]], dtype=float)

for i in range(n_iter):
    path = Viterbi(X, list(range(len(states))), T, E)
    T, E = hmm_params(X, path, alphabet_num, states_num)

f = StringIO()
DataFrame(T.round(3), index=states, columns=states).to_csv(f, sep='\t', float_format='%g')
f.write('--------\n')
DataFrame(E.round(3), index=states, columns=alphabet).to_csv(f, sep='\t', float_format='%g')

open('rosalind_ba10i_sub.txt', 'wt').write(f.getvalue().rstrip())
